---
layout: post
title: Speeding up incremental builds in Xcode
author: maciej.piotrowski
tags: [tech, ios, xcode, swift, objectivec]
---

## Slow builds

Programmers who have ever developed in the early days of **Swift** language might remember ridiculous times it took to compile the whole project. For large and complicated codebase times used to range between 10 to even 40 minutes. Over the years our toolset has improved alongside with compilation times, but slow build times of source code can still be a nightmare. 

When we wait a few minutes for a build we navigate ourselves towards different activities and start e.g. watching funny animal pictures or YouTube videos, easily **loosing context** of the task at hand. What becomes annoying for us is **slow feedback** of code correctness.

In the [past issue]() my colleague has written about a solution to slow **clean** builds. In this post I will focus on **warm** builds improvement.

## Clean and incremental builds and ...

There are two terms used in the realm of [Xcode](https://developer.apple.com/xcode/) when it comes to distinguishing types of compilation: **clean** and **incremental** build. The first refers to the time it takes to build a project from scratch. The latter is the time it takes to build only whatever changed since the last build and to integrate the changes into a build product.

You might also be familiar with the term **warm** build. It's used interchangeably with **incremental** build term, but for the sake of this post I will be using it to refer to *the time it takes to build a product since the last clean build without introducing any source code changes*.

## Why and what for?

Why bothering with improving **warm** build times? Well, for a small projects built on super fast workstations it might take a fraction of a second to do a warm build, but as projects grow and multiple *Build Phases* get added to a target so grow the build times. These times are noticeable especially when one builds the target without an introduction of changes to the source code.

Before we started improving the warm build of the Allegro app for iOS platform it took 18 seconds to perform the build on our Continuous Integration (CI) servers (Mac Mini, 6-Core 3.2 GHz CPU, 32 GB Ram).

Is 18 seconds too much? When you put it into a perspective of 1 year:

18 seconds * 6 builds per hour * 8 hours per day * 20 days per month * 12 months per year = 3456 seconds yearly

It means that on average a programmer spends around 60 minutes yearly to wait for a feedback if their code is correct. Is it much? Maybe not, but it definitely hinders developer's experience and distracts the developer from their job.

To make the developer's experience better, we, the iOS Mobile Core Team at Allegro, have set the goal to minimize the time developers spend between hitting the build button and getting the feedback on their code as quickly as possible. 

How could the goal be achieved? Well, before I answer that, let's put some light onto how to actually measure build times.

## Measurements

Developers building software for Apple platforms use the [Xcode](https://developer.apple.com/xcode/) application which has a command line interface called `xcodebuild`. The Xcode has an option to output times for build phases from the menu `Product > Perform Action > Build With Timing Summary` (doesn't seem to work on Xcode 12.2 at the time of writing this blog post). To get build times with `xcodebuild` for our Allegro app for each build phase of the main target the following command can be used:

```
xcodebuild -workspace 'Allegro/Allegro.xcworkspace' \
-scheme 'Allegro' \
-configuration 'Debug' \
-sdk 'iphonesimulator' \
-arch 'x86_64' \
-showBuildTimingSummary \
build \
| sed -n -e '/Build Timing Summary/,$p'
```

In the case of the Allegro app it outputs the following lines when I do a **clean** build with Xcode 12.2's `xcodebuild` (Mac Book Pro 2.2 GHz 6-Core Intel Core i7 CPU, 32 GB RAM):

```
Build Timing Summary

CompileC (49 tasks) | 174.459 seconds

CompileSwiftSources (3 tasks) | 31.747 seconds

CompileStoryboard (6 tasks) | 29.057 seconds

PhaseScriptExecution (8 tasks) | 22.320 seconds

Ditto (21 tasks) | 22.282 seconds

Ld (3 tasks) | 13.432 seconds

CompileAssetCatalog (1 task) | 6.620 seconds

ValidateEmbeddedBinary (2 tasks) | 6.528 seconds

CompileXIB (1 task) | 5.000 seconds

CodeSign (3 tasks) | 1.419 seconds

CopyPNGFile (3 tasks) | 1.236 seconds

Touch (4 tasks) | 0.318 seconds

Libtool (1 task) | 0.241 seconds

LinkStoryboards (2 tasks) | 0.108 seconds
```

In the case of a **warm build** the only phases listed are:

```
Build Timing Summary

PhaseScriptExecution (6 tasks) | 23.350 seconds

ValidateEmbeddedBinary (2 tasks) | 2.424 seconds

** BUILD SUCCEEDED ** [27.238 sec]
```

Thanks to performing the **warm build** it can be easily notice that there's a room for improvement when it comes to `PhaseScriptExecution` part of the build process. This is the part over which we have the control of. Let's see, what can we do in order to speed up the build time by playing with which and how scripts get executed.

## Cleaning up run scripts
- skrypty w debug które nie muszą lecieć (np. copy symbols to 3rd party servers: Firebase Crashlytics, NewRelic)
- Copy Bundles
    - script input/output (Xcode 12 dependency analysis)

[Pull Request](https://stash.allegrogroup.com/projects/IOSBUYERS/repos/buyers-app/pull-requests/12645/diff#Allegro/StaticModules/copy_static_module_bundles.sh)

Wykorzystujemy funkcjonalność Xcode'a 12 o nazwie **dependency analysis** dla skryptów wykonywanych w *Build Phases*. Skrypty są wykonywane przez system budowania tylko gdy "wejście" skryptów się zmienia lub "wyjście" (czyli produkt) skryptu nie istnieje. Ale był pewien problem. Nasze skrypty nie definiowały wejścia i wyjścia... Ale dla dwóch skryptów już to zmieniliśmy!
Projekt Allegro jako jedną ze swych faz budowania posiada skrypt kopiujący `.bundle` zzasobami. W poprzedniej wersji skryptu stosowaliśmy komendę `find` do znalezienia folderów `.bundle` we frameworkach w Derived Data. Wróciliśmy do listy `.bundle` do skopiowania (podobnie jak to było w dawnych czasach - to ta lista, którą trzeba było utrzymywać ręcznie zanim zaczęliśmy pracę nad **modulegen** i **steve** 😉). Tym razem lista jest w formacie `.xcfilelist` i dzięki temu możemy korzystać z **dependency analysis** Xcode'a 12 co przyspiesza **warm build**. Lista generowana jest przez `steve fixme` na podstawie dostępnych modułów produkcyjnych 🙂.

- Carthage copy dylibs
- disable code signing for simulator https://eisel.me/signing
```
OTHER_CODE_SIGN_FLAGS[sdk=iphonesimulator*] = --resource-rules=Configuration/ResourceRules-Debug.plist
OTHER_CODE_SIGN_FLAGS[sdk=iphoneos*] =
CODE_SIGNING_ALLOWED[sdk=iphonesimulator*] = NO
CODE_SIGNING_ALLOWED[sdk=iphoneos*] = YES
OTHER_LDFLAGS[sdk=iphonesimulator*] = -Wl,-sectcreate,__TEXT,__entitlements,Allegro/allegro_development.entitlements
OTHER_LDFLAGS[sdk=iphoneos*] =
```

## Outcomes

```
Build Timing Summary

PhaseScriptExecution (6 tasks) | 3.666 seconds

ValidateEmbeddedBinary (2 tasks) | 2.314 seconds

** BUILD SUCCEEDED ** [7.500 sec]
```

## Long term goal
incremental = clean
- current: 4s on the CI; Xs on Workstations
- DTK time? -> M1 chip might get speed up

## Links
https://www.onswiftwings.com/posts/build-time-optimization-part1/
https://www.onswiftwings.com/posts/build-time-optimization-part2/


[//TODO: authors.md] (https://stash.allegrogroup.com/projects/PROMOIT/repos/opensource/browse/README.md)
