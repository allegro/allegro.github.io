---
layout: post
title: Kotlin null safety and its performance considerations - part 1.
author: konrad.kaminski
tags: [tech, java, kotlin, jvm, performance, null, x86, x64, assembler]
---

[Kotlin](http://kotlinglang.org) may seem like a new kid on the block -- it's been officially released only in [February](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/).
Its history however dates [few years back](http://www.infoworld.com/article/2622405/java/jetbrains-readies-jvm-based-language.html)
and it's mature and stable enough to be used for developing solid long-standing applications.
Therefore at [Allegro](http://allegro.pl) we decided to give it a chance -- we built our new
shiny application using Kotlin as it's primary language and we do not regret it.

One of the first features that Kotlin developer learns is its approach to handling `null` values.
It is quite interesting -- especially at times like these when the most popular way of handling
this problem is to use some kind of [Option monad](https://en.wikipedia.org/wiki/Option_type).
As we'll soon see Kotlin actually does not introduce any new special wrapper type - it uses regular Java
types albeit with slight variance.

## Null-safe world

In Kotlin when you declare a variable, a field or a function parameter by default they cannot
be `null`. For example let's suppose we have a class `Greeter` which has a function `hello` that
by default prints greeting message on the standard output:

```kotlin
class Greeter {
  fun hello(who: String): Unit {
    println ("Hello $who")
  }
}
```

We declared `who` to be of type `String` which is interpreted by a compiler that `who` cannot be
`null`. If we want to declare a _nullable_ parameter we have to add a question mark at the
end of the type name:

```kotlin
class Greeter {
  fun hello(who: String?): Unit {
    println ("Hello $who")
  }
}
```

This simple solution turns out to be very convenient and strong at the same time. It divides
the world of our code into two areas: one where `null`s are allowed and one when it isn't.
As we'll see in a moment Kotlin provides quite a range of helpful features which makes the
transition between those areas entirely safe. Yet we have to be aware of a few issues we may
encounter which may come as a surprise.

To fully explore how Kotlin handles `null`s underneath we'll take a closer look at the code
generated by Kotlin compiler. We'll do it on two levels: first we'll inspect the output
bytecode -- although for brevity we'll actually see an equivalent Java code. Then, in [the second part](???) - for
some interesting cases we'll have a glance at the machine code generated by JVM JIT compiler.

### Smart casts

Since Kotlin compiler knows the type of every variable, field, function parameter, etc. it
can check if an incorrect assignment takes place and throw an error in such case. In the
code below we try to assign a _nullable_ reference to a _non-null_ property:

```kotlin
class User {
  private var username: String = ""

  fun setName(newName: String?) {
    username = newName // the compiler will indicate an error here
  }
}
```

What if we wanted to check if the reference is not `null` and only then assign it to a property?
The following code provides an answer:

```kotlin
class User {
  private var username: String = ""

  fun setName(newName: String?) {
    if (newName == null)
      throw NullPointerException("Name cannot be null!")

    username = newName // here the compiler knows that newName cannot be null and therefore it's type is String and not String?
  }
}
```

This construct -- where the compiler can infer that the reference cannot be `null` -- is called
smart casting as it seems to cast the reference from `String?` to `String`.

There is one thing we have to bear in mind when using smart casts. We can only do it with
references that cannot be changed between the checkpoint and the actual assignment. In the
code above the reference was taken from the function parameter which cannot change in the
course of function execution. If we were to take the reference from some read/write property
the compiler would not allow it:

```kotlin
class UserRequest {
  var username: String? = null
}

class User {
  private var username: String = ""

  fun setNameFrom(request: UserRequest) {
    if (request.username == null)
      throw NullPointerException("Name cannot be null!")

    username = request.username // here the compiler cannot be sure that request.username is not null - it could change in some other thread right after the if
  }
}
```

### The !! operator

The code shown in the above example looks quite common. When we expect a reference to be not `null`
and this assumption proves wrong we may want to throw `NullPointerException`. Kotlin
has a special syntax for such cases:

```kotlin
class User {
  private var username: String = ""

  fun setName(newName: String?) {
    username = newName!! // the type of newName!! is String and the compiler generates a runtime check to be sure of that...
  }
}
```

The equivalent Java code as taken from the bytecode generated by the Kotlin compiler is as follows:

```java
import org.jetbrains.annotations.Nullable;

import static kotlin.jvm.internal.Intrinsics.throwNpe;

public final class User {
  private String username = "";

  public void setName(@Nullable newName: String) {
    if (newName == null) {
      throwNpe();
    }

    username = newName;
  }
}
```

We can see a couple of interesting things here:

1. The `newName` parameter of the `setName` method gets an annotation indicating it's
_nullability_. This annotation is used internally by Kotlin compiler and [IntelliJ IDEA](https://www.jetbrains.com/idea/),
although one can think of using it also in tools like [FindBugs](http://findbugs.sourceforge.net/)
or [Checker Framework](http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#nullness-checker).
2. The code in `setName` has a striking resemblance (surprise!) to the code we
wrote in our smart cast example. The only difference is the usage of the `throwNpe` method.
We'll delve into the details of it a bit later -- for now we can make a simplification and
state  that it throws `KotlinNullPointerException` (which extends `NullPointerException`).

### Parameter validation

So far in our examples we didn't have methods which were not private and at the same time
had non-`null` parameters. In order to gain some insight into what happens in such situations
lets modify our code:

```kotlin
class User {
  var username: String = ""

  fun setName(newName: String) {
    username = newName
  }
}
```

One obvious method that we'd like to have a look at is the `setName` method. But the
equivalent Java code contains a surprise:

```java
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import static kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull;

public class User {
  @NotNull
  private String username = "";

  @NotNull
  public String getUsername() {
    return username;
  }

  public void setUsername(@NotNull String value) {
    checkParameterIsNotNull(value, "<set-?>");

    username = value;
  }

  public void setName(@NotNull String newName) {
    checkParameterIsNotNull(value, "newName");

    username = value;
  }
}
```

We can see that we now have two additional methods (`getUsername` and `setUsername`) and
the `username` field earned a `@NotNull` annotation. We're witnesses to how Kotlin
compiler manages properties in classes:

1. If it is `private` then a property is simply a field of the class with no special annotations --
this is because this property is not visible anywhere outside the class and therefore
Kotlin compiler can optimize access to it and it can be sure that it will always be non-`null`,
2. if is not `private` then a property is actually a field with a pair of setter and getter methods --
this is because the property is visible to the outside world and Kotlin compiler must check
upon every access to it that is non-`null` and at the same time provide this information to this
outside world.

We can also observe that to check whether a value of a parameter is not `null` the `checkParameterIsNotNull`
method is used. Again we'll investigate it a bit later. For now it is enough to say that
upon receiving a `null` value an `IllegalArgumentException` will be thrown.

### Elvis operator

When we have a `null` value there are situations when instead of throwing an exception we'd
rather do something else. We can compare it to a `default` block in Java `switch` statement.
A simple `if` statement with an `else` should suffice here, but Kotlin has a special syntax
for it -- a famous [Elvis operator](https://en.wikipedia.org/wiki/Elvis_operator).

Let's suppose that for a `null` value we'd like to set a `username` to `"N/A"`:

```kotlin
class User {
  private var username: String = ""

  fun setName(newName: String?) {
    username = newName ?: "N/A"
  }
}
```

The equivalent Java code is:

```java
import org.jetbrains.annotations.Nullable;

public class User {
  private String username = "";

  public void setName(@Nullable String newName) {
    username = (newName != null) ? newName : "N/A";
  }
}
```

The Kotlin syntax is more concise and it's also worth mentioning that the expression after
the Elvis operator is lazy and it can also throw an exception. So it's completely legal
to have this kind of code:

```kotlin
class User {
  private var username: String = ""

  fun setName(newName: String?) {
    username = newName ?: throw RuntimeException("Are you nuts?")
  }
}
```

The equivalent Java code is:

```java
import org.jetbrains.annotations.Nullable;

public class User {
  private String username = "";

  public void setName(@Nullable String newName) {
    if (newName != null)
      username = newName;
    else
      throw new RuntimeException("Are you nuts?");
  }
}
```

### Safe calls and let/run/apply functions

There are circumstances when we have a possibly `null` object and want to invoke a method
on it but only if it is actually not-`null` (because otherwise we would get `NullPointerException`).
We can do it with simple `if`, but Kotlin provides a fancy `?.` operator to make the code
more compact. So this code:

```kotlin
data class SimpleUser(var name: String)

object Users {
  private val userMap = mapOf(1 to SimpleUser("John"))

  @JvmStatic
  fun getUser(userId: Int): SimpleUser? = userMap[userId]
}

fun getUserName(userId: Int): String? =
        getUser (userId)?.name
```

has the following equivalent Java code for `getUserName`:

```java
@Nullable
public String getUserName(int userId) {
  SimpleUser simpleUser = getUser(userId);
  return simpleUser != null ? simpleUser.getName() : null;
}
```

Indeed the Kotlin code is a lot shorter and more expressive. To further aid developers
Kotlin provides three convenient [higher-order functions](https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions):
`let`, `run` and `apply`. Although they are not directly related to `null`-safety issues
we often use them with potentially `null` objects. Below you can find some code examples -- they should give you an intuition about when
and how to use them.

#### let

Let's look at the following code with [`let`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html) (pardon the pun):

```kotlin
fun findUserNameWithLet(userId: Int): String? =
    getUser (userId)?.let { it.name }
```

`let` is essentially an [extension function](https://kotlinlang.org/docs/reference/extensions.html#extension-functions)
that can be invoked on any type. It takes a [lambda expression](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions)
as its parameter and calls it with `this` as an argument. If a _lambda expression_ has only
one parameter then we may skip declaring it and simply access it via the name... `it`.
Therefore in the example above `this` inside the lambda (`this` is of type `SimpleUser` -- the type
returned by the `getUser` method) is accessible as `it`. The value of the _lambda expression_ is
returned as the result of the `let` function.

The equivalent Java code for `findUserNameWithLet` is as follows:

```java
@Nullable
public String findUserNameWithLet(int userId) {
  String result;

  SimpleUser simpleUser = getUser(userId);
  if (simpleUser != null) {
    SimpleUser it = simpleUser;

    result = it.getName(); // { it.name }
  } else {
    result = null;
  }

  return result;
}
```

`let` is usually used if we want to perform some operations on a non-`null` object and
return the result of these operations while simply returning `null` for `null` objects.

#### run

The [`run`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html) function is a slight
variation of `let`. It takes a parameterless _lambda expression_ as its parameter and the
object on which you invoke `run` can be accessed via `this` inside the _lambda expression_.
Just like in `let` the result of the _lambda expression_ is returned as the result of the
`run` function.

Let's see an example:

```kotlin
fun findUserNameWithRun(userId: Int): String? =
    getUser (userId)?.run { name }
```

and the equivalent Java code:

```java
@Nullable
public String findUserNameWithRun(int userId) {
  String result;

  SimpleUser simpleUser = getUser(userId);
  if (simpleUser != null) {
    SimpleUser $receiver = simpleUser;

    result = $receiver.getName(); // { name }
  } else {
    result = null;
  }

  return result;
}
```

As we can see there is little difference with `let` -- the Kotlin code is similar although
with `run` it is even more concise.

#### apply

The last of the three convenient functions we're going to talk about is [`apply`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html).
The following code illustrates its usage:

```kotlin
fun findUserNameWithApply(userId: Int): SimpleUser? =
      getUser (userId)?.apply { name = "Jane" }
}
```

`apply` is similar to `run` -- it is an _extension function_ which takes a
parameterless _lambda expression_ as its parameter and the object on which you invoke `apply`
can be accessed via `this` inside the _lambda expression_. However, the return value of
`apply` is the object on which you invoke it (and not the _lambda expression_ result).

The equivalent Java code for `findUserNameWithApply` is as follows:

```java
@Nullable
public SimpleUser findUserNameWithApply(int userId) {
  SimpleUser result;

  SimpleUser simpleUser = getUser(userId);
  if (simpleUser != null) {
    SimpleUser $receiver = simpleUser;

    $receiver.setName("Jane"); // { name = "Jane" }

    result = simpleUser;
  } else {
    result = null;
  }

  return result;
}
```

The most common reason to use `apply` is the initialisation of an object. If there is something
we have to do before returning an object (and simply return `null` if it is `null`) then
`apply` is the way to go.

### Platform types

So far we have not talked about the interoperability with Java. While from Java code point
of view with regard to `null`-safety nothing unusual happens if we call Kotlin code, there
is a difference when we want to call Java code from Kotlin. This is especially important for
the case of the result returned from Java methods where Kotlin compiler has to take some precautions.
After all it does not know if the value returned can be `null` or not.

To resolve the problem of the lack of knowledge about _nullability_ of values returned from
Java code Kotlin introduces the concept of [platform types](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types).
In essence _platform type_ is used every time Kotlin compiler encounters an invocation
of Java method which was not generated by Kotlin compiler. At the same time a developer cannot
explicitly declared anything to be of _platform type_ -- it exists solely when Kotlin compiler
infers it from the code.

Let's look at some code samples which present most of things you have to know about _platform types_:

```kotlin
fun writeOutNullable(s: String?) = println(s)

fun nullableCase() {
  val value = System.getProperty("key") // value has a platform type String!
  writeOutNullable(value)               // The ! after a type indicates it's a platform type
}
```

The equivalent Java code is:

```java
public void nullableCase() {
  String value = System.getProperty("key");
  writeOutNullable(value);
}
```

We can see nothing special here - the _platform type_ is taken as is when it is converted to
a _nullable_ type.

Let's see what happens when the target type is non-`null`:

```kotlin
fun writeOut(s: String) {
  println(s)
}

fun nonNullCase() {
  val value = System.getProperty("key") // value has a platform type String!

  writeOut(value)
}
```

The equivalent Java code is:

```java
import static kotlin.jvm.internal.Intrinsics.checkExpressionValueIsNotNull;

public void nonNullCase() {
  String value = System.getProperty("key");

  checkExpressionValueIsNotNull(value, "value");
  writeOut(value);
}
```

Now we have a validation in the generated code. `writeOut` expectes a non-`null` type, but the
`value` type is _platform type_ and in theory it could be `null`. Therefore the compiler
produces a runtime check with the help of `checkExpressionValueIsNotNull` method which we'll
explore later.

Next example shows the code where only Java methods are used.

```kotlin
fun pureJavaCase() {
  val value = System.getProperty("key") // value has a platform type String!

  System.setProperty("other_key", value)
}
```

The equivalent Java code is:

```java
public void pureJavaCase() {
  String value = System.getProperty("key");

  System.setProperty("other_key", value);
}
```

Just like when we had the _nullable_ types no runtime check is generated. After all at no
place in the code we pass the value to the code which explicitly expects non-`null` values.

One might ask what happens after the value is checked not to be `null` -- does the compiler treat
it as a non-`null` value?

```kotlin
fun doubleCheckCase() {
  val value = System.getProperty("key") // value has a platform type String!

  writeOut(value)
  writeOut(value)
}
```

The equivalent Java code is:

```java
public void doubleCheckCase() {
  String value = System.getProperty("key");

  checkExpressionValueIsNotNull(value, "value");
  writeOut(value);
  checkExpressionValueIsNotNull(value, "value");
  writeOut(value);
}
```

It appears it doesn't -- the runtime checks are generated each time the conversion to non-`null`
type takes place.

The following example shows assigning the value with _platform type_ to some variable without
explicitly stating this variable type:

```kotlin
fun assignCase() {
  val value = System.getProperty("key") // value has a platform type String!
  val newValue = value // newValue has a platform type String!

  writeOut(newValue)
}
```

The equivalent Java code is:

```java
public void assignCase() {
  String value = System.getProperty("key");
  String newValue = value;

  checkExpressionValueIsNotNull(newValue, "newValue");
  writeOut(newValue);
}
```

No surprise here -- the type of the variable `newValue` is also a _platform type_ and runtime checks
are generated.

What if we explicitly state the variable's type?

```kotlin
fun explicitCase() {
  val value = System.getProperty("key") // value has a platform type String!

  val nullableValue: String? = value
  writeOutNullable(nullableValue)

  val nonNullValue: String = value
  writeOut(nonNullValue)
  writeOut(nonNullValue)
}
```

The equivalent Java code is:

```java
public void explicitCase() {
  String value = System.getProperty("key");

  String nullableValue = value;
  writeOutNullable(nullableValue);

  checkExpressionValueIsNotNull(value)
  String nonNullValue = value;
  writeOut(nonNullValue);
  writeOut(nonNullValue);
}
```

As we can see the rule is simple - every time we go from the _plaform type_ to non-`null` type
a runtime check is generated. Once we're in the `null`-safe world no additional validation is needed.

In the examples above we've seen that the `checkExpressionValueIsNotNull` method takes a variable
name as the second parameter. This is done so that when a `null` value is passed you'll see
an error message with the name of the variable in it. But as the name of the method states
it does not have to be a variable. In fact it's always an expression, but in the above cases
we had simple one-variable expressions. If we had a true expression...:

```kotlin
fun funnyCase() {
  writeOut(System.getProperty("key"))
}
```

The equivalent Java code is:

```java
public void funnyCase() {
  String tmp = System.getProperty("key");
  checkExpressionValueIsNotNull(tmp, "System.getProperty(\"key\")");
  writeOut(tmp);
}
```

If we now call `funnyCase` (and there is no `"key"` system property set) then we'll see the
following stack trace:

```
Exception in thread "main" java.lang.IllegalStateException: System.getProperty("key") must not be null
	at pl.kk.test.kotlin.PlatformTypesKt.funnyCase(PlatformTypes.kt:54)
	at pl.kk.test.kotlin.FunnyCaseCall.main(PlatformTypes.kt:60)
```

### Summary

We've taken a tour on the different Kotlin language constructs where you could observe the
code generated by the compiler. During regular development you rarely have to think
about how things work underneath. Nonetheless it is useful to know a thing or two about it.
And if you're interested in how the performance of some of those constructs is affected
check out the [second part](???) of this article.
